/** biome-ignore-all lint/suspicious/noTemplateCurlyInString: shell variable interpolation */

import { type CommandResult, err, ok } from "../utils/result";
import { COMMANDS, getAllNames } from "./registry";

export { commandDef } from "./completions-def";

function generateFishCompletions(): string {
  const lines: string[] = [
    "# Fish completions for wct",
    "# Generated by: wct completions fish",
    "",
    "# Erase inherited completions (e.g. from alias --wraps)",
    "complete -c wct -e",
    "",
    "# Disable file completions by default",
    "complete -c wct -f",
    "",
    "# Helper: list git branches for completion",
    "function __wct_branches",
    "    git branch --format='%(refname:short)' 2>/dev/null",
    "end",
    "",
    "# Helper: list branches that have worktrees",
    "function __wct_worktree_branches",
    "    git worktree list --porcelain 2>/dev/null | string replace -rf '^branch refs/heads/(.+)' '$1'",
    "end",
    "",
    "# Commands",
  ];

  for (const cmd of COMMANDS) {
    lines.push(
      `complete -c wct -n '__fish_use_subcommand' -a '${cmd.name}' -d '${cmd.description}'`,
    );
    if (cmd.aliases) {
      for (const alias of cmd.aliases) {
        lines.push(
          `complete -c wct -n '__fish_use_subcommand' -a '${alias}' -d '${cmd.description}'`,
        );
      }
    }
  }

  lines.push("");
  lines.push("# Global options");
  lines.push(
    "complete -c wct -n '__fish_use_subcommand' -s h -l help -d 'Show help message'",
  );
  lines.push(
    "complete -c wct -n '__fish_use_subcommand' -s v -l version -d 'Show version number'",
  );

  lines.push("");
  lines.push("# Per-command options");

  for (const cmd of COMMANDS) {
    if (!cmd.options) continue;
    const names = getAllNames(cmd);
    for (const opt of cmd.options) {
      const parts = [
        "complete -c wct",
        `-n '__fish_seen_subcommand_from ${names.join(" ")}'`,
      ];
      if (opt.short) parts.push(`-s ${opt.short}`);
      parts.push(`-l ${opt.name}`);
      if (opt.type === "string") parts.push("-r");
      parts.push(`-d '${opt.description}'`);
      lines.push(parts.join(" "));
    }
  }

  const branchCommands = COMMANDS.filter(
    (cmd) =>
      cmd.args?.includes("<branch>") && cmd.completionType !== "worktree",
  )
    .flatMap((cmd) => getAllNames(cmd))
    .join(" ");

  const worktreeCommands = COMMANDS.filter(
    (cmd) => cmd.completionType === "worktree",
  )
    .flatMap((cmd) => getAllNames(cmd))
    .join(" ");

  if (branchCommands) {
    lines.push("");
    lines.push("# Branch completions");
    lines.push(
      `complete -c wct -n '__fish_seen_subcommand_from ${branchCommands}' -a '(__wct_branches)' -d 'Branch name'`,
    );
  }

  if (worktreeCommands) {
    lines.push("");
    lines.push("# Worktree branch completions");
    lines.push(
      `complete -c wct -n '__fish_seen_subcommand_from ${worktreeCommands}' -a '(__wct_worktree_branches)' -d 'Branch name'`,
    );
  }

  lines.push("");
  lines.push("# Shell completions for 'completions' subcommand");
  lines.push(
    "complete -c wct -n '__fish_seen_subcommand_from completions' -a 'fish' -d 'Fish shell'",
  );
  lines.push(
    "complete -c wct -n '__fish_seen_subcommand_from completions' -a 'bash' -d 'Bash shell'",
  );
  lines.push(
    "complete -c wct -n '__fish_seen_subcommand_from completions' -a 'zsh' -d 'Zsh shell'",
  );

  lines.push("");
  return lines.join("\n");
}

function generateBashCompletions(): string {
  const cmdNames = COMMANDS.flatMap((cmd) => getAllNames(cmd)).join(" ");
  const branchCommands = COMMANDS.filter(
    (cmd) =>
      cmd.args?.includes("<branch>") && cmd.completionType !== "worktree",
  ).flatMap((cmd) => getAllNames(cmd));
  const worktreeCommands = COMMANDS.filter(
    (cmd) => cmd.completionType === "worktree",
  ).flatMap((cmd) => getAllNames(cmd));

  const lines: string[] = [
    "# Bash completions for wct",
    "# Generated by: wct completions bash",
    "#",
    '# Add to ~/.bashrc: eval "$(wct completions bash)"',
    "",
    "_wct_branches() {",
    "    git branch --format='%(refname:short)' 2>/dev/null",
    "}",
    "",
    "_wct_worktree_branches() {",
    "    git worktree list --porcelain 2>/dev/null | sed -n 's|^branch refs/heads/||p'",
    "}",
    "",
    "_wct() {",
    '    local cur="${COMP_WORDS[COMP_CWORD]}"',
    '    local cword="$COMP_CWORD"',
    "",
    "    if [[ $cword -eq 1 ]]; then",
    `        COMPREPLY=($(compgen -W '${cmdNames}' -- "$cur"))`,
    "        return",
    "    fi",
    "",
    '    local cmd="${COMP_WORDS[1]}"',
    '    case "$cmd" in',
  ];

  for (const cmd of COMMANDS) {
    if (cmd.name === "completions") continue;

    const opts: string[] = [];
    if (cmd.options) {
      for (const opt of cmd.options) {
        opts.push(`--${opt.name}`);
        if (opt.short) opts.push(`-${opt.short}`);
      }
    }
    const allNames = getAllNames(cmd);
    const isBranchCmd = allNames.some((n) => branchCommands.includes(n));
    const isWorktreeCmd = allNames.some((n) => worktreeCommands.includes(n));
    const completionFn = isWorktreeCmd
      ? "_wct_worktree_branches"
      : "_wct_branches";

    lines.push(`        ${allNames.join("|")})`);
    if (opts.length > 0) {
      lines.push(
        `            COMPREPLY=($(compgen -W '${opts.join(" ")}' -- "$cur"))`,
      );
    }
    if (isBranchCmd || isWorktreeCmd) {
      if (opts.length > 0) {
        lines.push('            if [[ "$cur" != -* ]]; then');
        lines.push(
          `                COMPREPLY=($(compgen -W "$(${completionFn})" -- "$cur"))`,
        );
        lines.push("            fi");
      } else {
        lines.push(
          `            COMPREPLY=($(compgen -W "$(${completionFn})" -- "$cur"))`,
        );
      }
    }
    lines.push("            ;;");
  }

  lines.push("        completions)");
  lines.push(
    "            COMPREPLY=($(compgen -W 'fish bash zsh' -- \"$cur\"))",
  );
  lines.push("            ;;");
  lines.push("    esac");
  lines.push("}");
  lines.push("");
  lines.push("complete -F _wct wct");
  lines.push("");

  return lines.join("\n");
}

function generateZshCompletions(): string {
  const branchCommands = COMMANDS.filter(
    (cmd) =>
      cmd.args?.includes("<branch>") && cmd.completionType !== "worktree",
  ).flatMap((cmd) => getAllNames(cmd));
  const worktreeCommands = COMMANDS.filter(
    (cmd) => cmd.completionType === "worktree",
  ).flatMap((cmd) => getAllNames(cmd));

  const lines: string[] = [
    "#compdef wct",
    "# Zsh completions for wct",
    "# Generated by: wct completions zsh",
    "#",
    '# Add to ~/.zshrc: eval "$(wct completions zsh)"',
    "# Or save to a file in your $fpath",
    "",
    "_wct_branches() {",
    "    local branches",
    "    branches=($(git branch --format='%(refname:short)' 2>/dev/null))",
    "    _describe 'branch' branches",
    "}",
    "",
    "_wct_worktree_branches() {",
    "    local branches",
    "    branches=($(git worktree list --porcelain 2>/dev/null | sed -n 's|^branch refs/heads/||p'))",
    "    _describe 'branch' branches",
    "}",
    "",
    "_wct() {",
    "    local -a commands",
    "    commands=(",
  ];

  for (const cmd of COMMANDS) {
    lines.push(`        '${cmd.name}:${cmd.description}'`);
    if (cmd.aliases) {
      for (const alias of cmd.aliases) {
        lines.push(`        '${alias}:${cmd.description}'`);
      }
    }
  }
  lines.push("    )");
  lines.push("");
  lines.push("    _arguments -C \\");
  lines.push("        '(-h --help)'{-h,--help}'[Show help message]' \\");
  lines.push(
    "        '(-v --version)'{-v,--version}'[Show version number]' \\",
  );
  lines.push("        '1:command:->command' \\");
  lines.push("        '*::arg:->args'");
  lines.push("");
  lines.push('    case "$state" in');
  lines.push("        command)");
  lines.push("            _describe 'wct command' commands");
  lines.push("            ;;");
  lines.push("        args)");
  lines.push('            case "$words[1]" in');

  for (const cmd of COMMANDS) {
    const allNames = getAllNames(cmd);
    const isBranchCmd = allNames.some((n) => branchCommands.includes(n));
    const isWorktreeCmd = allNames.some((n) => worktreeCommands.includes(n));
    const hasOpts = cmd.options && cmd.options.length > 0;
    const completionFn = isWorktreeCmd
      ? "_wct_worktree_branches"
      : "_wct_branches";

    if (!isBranchCmd && !isWorktreeCmd && !hasOpts) continue;

    lines.push(`                ${allNames.join("|")})`);

    if (hasOpts && cmd.options) {
      lines.push("                    _arguments \\");
      const optLines: string[] = [];
      for (const opt of cmd.options) {
        if (opt.short) {
          if (opt.type === "string") {
            optLines.push(
              `                        '(-${opt.short} --${opt.name})'{-${opt.short},--${opt.name}}'[${opt.description}]:${opt.placeholder || opt.name}:'`,
            );
          } else {
            optLines.push(
              `                        '(-${opt.short} --${opt.name})'{-${opt.short},--${opt.name}}'[${opt.description}]'`,
            );
          }
        } else {
          if (opt.type === "string") {
            optLines.push(
              `                        '--${opt.name}[${opt.description}]:${opt.placeholder || opt.name}:'`,
            );
          } else {
            optLines.push(
              `                        '--${opt.name}[${opt.description}]'`,
            );
          }
        }
      }
      if (isBranchCmd || isWorktreeCmd) {
        optLines.push(`                        '*:branch:${completionFn}'`);
      }
      lines.push(optLines.join(" \\\n"));
      lines.push("                    ;;");
    } else if (isBranchCmd || isWorktreeCmd) {
      lines.push(`                    ${completionFn}`);
      lines.push("                    ;;");
    }
  }

  lines.push("                completions)");
  lines.push("                    local -a shells");
  lines.push(
    "                    shells=('fish:Fish shell' 'bash:Bash shell' 'zsh:Zsh shell')",
  );
  lines.push("                    _describe 'shell' shells");
  lines.push("                    ;;");
  lines.push("            esac");
  lines.push("            ;;");
  lines.push("    esac");
  lines.push("}");
  lines.push("");
  lines.push("compdef _wct wct");
  lines.push("");

  return lines.join("\n");
}

export function completionsCommand(shell: string | undefined): CommandResult {
  if (!shell) {
    return err(
      "Missing shell name\n\nUsage: wct completions <shell>\nSupported shells: fish, bash, zsh",
      "missing_shell_arg",
    );
  }

  switch (shell) {
    case "fish":
      console.log(generateFishCompletions());
      return ok();
    case "bash":
      console.log(generateBashCompletions());
      return ok();
    case "zsh":
      console.log(generateZshCompletions());
      return ok();
    default:
      return err(
        `Unsupported shell: ${shell}\nSupported shells: fish, bash, zsh`,
        "unsupported_shell",
      );
  }
}
